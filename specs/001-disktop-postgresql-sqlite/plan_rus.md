# План реализации: Desktop Signal Analyzer с интеграцией базы данных

**Ветка**: `001-disktop-postgresql-sqlite` | **Дата**: 2025-10-04 | **Спецификация**: `/specs/001-disktop-postgresql-sqlite/spec.md`
**Ввод**: Спецификация функции из `/specs/001-disktop-postgresql-sqlite/spec.md`

## Поток выполнения (область команды /plan)
```
1. Загрузить спецификацию функции из пути Ввода
   → Если не найдено: ОШИБКА "Не найдена спецификация функции по пути {path}"
2. Заполнить Технический контекст (сканировать на ТРЕБУЕТ УТОЧНЕНИЯ)
   → Определить Тип проекта из структуры файловой системы или контекста (web=frontend+backend, mobile=app+api)
   → Установить Решение по структуре на основе типа проекта
3. Заполнить раздел Проверка конституции на основе содержания документа конституции.
4. Оценить раздел Проверка конституции ниже
   → Если существуют нарушения: Документировать в Отслеживание сложности
   → Если нет возможности обоснования: ОШИБКА "Сначала упростите подход"
   → Обновить Отслеживание прогресса: Начальная проверка конституции
5. Выполнить Фазу 0 → research.md
   → Если остаются ТРЕБУЕТ УТОЧНЕНИЯ: ОШИБКА "Разрешите неизвестные"
6. Выполнить Фазу 1 → contracts, data-model.md, quickstart.md, файл шаблона для конкретного агента (например, `CLAUDE.md` для Claude Code, `.github/copilot-instructions.md` для GitHub Copilot, `GEMINI.md` для Gemini CLI, `QWEN.md` для Qwen Code, или `AGENTS.md` для всех других агентов).
7. Переоценить раздел Проверка конституции
   → Если новые нарушения: Рефакторить дизайн, вернуться к Фазе 1
   → Обновить Отслеживание прогресса: Пост-дизайн проверка конституции
8. Планировать Фазу 2 → Описать подход генерации задач (НЕ СОЗДАВАТЬ tasks.md)
9. СТОП - Готово для команды /tasks
```

**ВАЖНО**: Команда /plan ОСТАНАВЛИВАЕТСЯ на шаге 7. Фазы 2-4 выполняются другими командами:
- Фаза 2: команда /tasks создает tasks.md
- Фазы 3-4: Выполнение реализации (вручную или через инструменты)

## Резюме
Desktop Signal Analyzer - это кроссплатформенное приложение для математического анализа сигналов с визуализацией в реальном времени, GPU ускорением и постоянным хранением в базе данных. Система предоставляет современный UI с плавными переходами, поддерживает 2D/3D построение графиков и спектральный анализ, реализует паттерны наблюдателя для обновлений в реальном времени и поддерживает слабую связанность между модулями. Обмен данными использует формат JSON с организованной структурой каталогов для входных/выходных/валидационных данных.

## Технический контекст
**Язык/Версия**: Python 3.12+  
**Основные зависимости**: PyQt6 (Qt 6.5), matplotlib (3.8), pyqtgraph (0.13), PyOpenGL (3.1), numpy (1.25), pandas (2.1), scipy (1.11), sympy (1.11)  
**Хранилище**: PostgreSQL или SQLite (выбирается пользователем), JSON файлы конфигурации, организованная структура каталогов данных  
**Тестирование**: pytest, pytest-qt для тестирования GUI  
**Целевая платформа**: Windows и Ubuntu desktop  
**Тип проекта**: single (настольное приложение)  
**Цели производительности**: 60+ FPS для визуализации в реальном времени, генерация сигналов за суб-миллисекунды, GPU ускорение для максимальной скорости  
**Ограничения**: <16ms операции GUI, стабильное использование памяти при длительной работе, работа в автономном режиме  
**Масштаб/Область**: Однопользовательское настольное приложение с модульной архитектурой

## Проверка конституции
*ВОРОТА: Должно пройти перед исследованием Фазы 0. Повторная проверка после дизайна Фазы 1.*

### Соответствие архитектуре Desktop-First
- ✅ **PyQt6 основной**: Использование PyQt6 для нативной производительности настольного приложения
- ✅ **Кроссплатформенность**: Поддержка Windows и Ubuntu через PyQt6
- ✅ **Фокус на производительности**: Требования GPU ускорения и визуализации в реальном времени

### Соответствие математической точности и производительности
- ✅ **NumPy/Pandas**: Векторизованные вычисления для обработки сигналов
- ✅ **SciPy/SymPy**: Научная точность для математических моделей
- ✅ **Суб-миллисекундный отклик**: Требования генерации сигналов в реальном времени

### Соответствие модульному дизайну компонентов
- ✅ **Независимые модули**: Слои GUI, визуализации, данных, вычислений
- ✅ **Четкие интерфейсы**: Хорошо определенные контракты данных между компонентами
- ✅ **Тестируемые компоненты**: Каждый модуль может быть протестирован независимо

### Соответствие разработке через тестирование
- ✅ **TDD обязательно**: Тесты для математических функций, взаимодействий GUI
- ✅ **Численная точность**: Валидация математических вычислений
- ✅ **Отзывчивость GUI**: Тестирование компонентов пользовательского интерфейса
- ✅ **Эффективность памяти**: Требования тестирования производительности

### Соответствие стандартам производительности в реальном времени
- ✅ **60+ FPS**: Требования осциллографа и анимированных графиков
- ✅ **16ms операции GUI**: Плавные взаимодействия пользовательского интерфейса
- ✅ **Стабильная память**: Длительная работа без утечек памяти
- ✅ **GPU ускорение**: Максимальная скорость вычислений и визуализации

## Фаза 0: Исследование и анализ технологий
*Генерировать research.md с анализом технологического стека и подходом к реализации*

### Области исследований
1. **Сравнение производительности PyQt6 vs Kivy**
   - Производительность графики в реальном времени
   - Кроссплатформенная совместимость
   - Возможности интеграции GPU

2. **Варианты GPU ускорения для Python**
   - Интеграция CUDA с numpy/scipy
   - OpenGL ускорение для визуализации
   - Бенчмарки производительности для обработки сигналов

3. **Паттерны интеграции базы данных**
   - Производительность PostgreSQL vs SQLite для временных рядов данных
   - Управление пулом подключений и транзакциями
   - Стратегии миграции данных

4. **Библиотеки визуализации в реальном времени**
   - Производительность pyqtgraph vs matplotlib
   - 3D рендеринг с PyOpenGL
   - Техники визуализации спектрального анализа

5. **Кроссплатформенное развертывание**
   - Распространение пакетов Windows и Ubuntu
   - Управление зависимостями
   - Скрипты установки

## Структура проекта

### Документация (эта функция)
```
specs/[###-feature]/
├── plan.md              # Этот файл (вывод команды /plan)
├── research.md          # Вывод Фазы 0 (команда /plan)
├── data-model.md        # Вывод Фазы 1 (команда /plan)
├── quickstart.md        # Вывод Фазы 1 (команда /plan)
├── contracts/           # Вывод Фазы 1 (команда /plan)
└── tasks.md             # Вывод Фазы 2 (команда /tasks - НЕ создается /plan)
```

### Исходный код (корень репозитория)
```
src/
├── gui/                    # Компоненты пользовательского интерфейса PyQt6
│   ├── main_window.py     # Главное окно приложения
│   ├── dialogs/           # Диалоги конфигурации и настроек
│   ├── widgets/           # Пользовательские виджеты для визуализации сигналов
│   └── controls/          # Панели элементов управления и ввода пользователя
├── visualization/         # Построение графиков и 3D визуализация
│   ├── 2d_plots.py       # 2D построение графиков с matplotlib/pyqtgraph
│   ├── 3d_plots.py       # 3D визуализация с PyOpenGL
│   ├── oscilloscope.py   # Дисплей осциллографа в реальном времени
│   └── spectral.py       # Визуализация спектрального анализа
├── data/                  # Обработка и анализ данных
│   ├── processing.py     # Алгоритмы обработки сигналов
│   ├── analysis.py       # Спектральный и гармонический анализ
│   ├── validation.py     # Проверки валидации и качества данных
│   └── import_export.py  # Функциональность импорта/экспорта данных
├── math/                  # Математические функции и генерация сигналов
│   ├── generators.py     # Генераторы математических сигналов
│   ├── functions.py      # Библиотека математических функций
│   ├── gpu_accel.py      # Обертка GPU ускорения
│   └── laws.py           # Определения математических законов
├── database/              # Операции и модели базы данных
│   ├── models.py         # Модели данных SQLAlchemy
│   ├── connection.py     # Управление подключением к базе данных
│   ├── operations.py     # CRUD операции базы данных
│   └── migrations.py     # Миграции схемы базы данных
├── config/                # Управление конфигурацией
│   ├── manager.py        # Управление файлами конфигурации
│   ├── validators.py     # Валидация конфигурации
│   └── templates.py      # Шаблоны конфигурации
└── utils/                 # Утилитарные функции и помощники
    ├── logger.py         # Конфигурация логирования
    ├── performance.py    # Мониторинг производительности
    ├── gpu.py            # Обнаружение и управление GPU
    └── helpers.py        # Общие утилитарные функции

tests/
├── unit/                  # Модульные тесты для отдельных модулей
├── integration/           # Интеграционные тесты для взаимодействия компонентов
├── performance/           # Тесты производительности и бенчмарки
└── gui/                   # Тестирование GUI с pytest-qt

config/                    # JSON файлы конфигурации
├── signal_generators/     # Шаблоны генерации сигналов
├── analysis_methods/      # Конфигурации алгоритмов анализа
├── visualization/         # Настройки графиков и отображения
├── database/             # Настройки подключения к базе данных
└── gpu/                  # Настройки GPU ускорения

data/                     # Каталоги хранения данных
├── input_data/           # Файлы входных сигналов
├── output_data/          # Сгенерированные результаты анализа
└── validation/           # Отчеты валидации и логи
```

**Решение по структуре**: Единое настольное приложение с модульной архитектурой. Выбранная структура поддерживает слабую связанность между компонентами, независимое тестирование и четкое разделение ответственности, как требует конституция.

## Фаза 0: План и исследование
1. **Извлечь неизвестные из Технического контекста** выше:
   - Для каждого ТРЕБУЕТ УТОЧНЕНИЯ → задача исследования
   - Для каждой зависимости → задача лучших практик
   - Для каждой интеграции → задача паттернов

2. **Генерировать и отправлять исследовательские агенты**:
   ```
   Для каждого неизвестного в Техническом контексте:
     Задача: "Исследовать {неизвестное} для {контекст функции}"
   Для каждого технологического выбора:
     Задача: "Найти лучшие практики для {технология} в {домен}"
   ```

3. **Консолидировать выводы** в `research.md` используя формат:
   - Решение: [что было выбрано]
   - Обоснование: [почему выбрано]
   - Рассмотренные альтернативы: [что еще оценивалось]

**Вывод**: research.md со всеми ТРЕБУЕТ УТОЧНЕНИЯ разрешенными

## Фаза 1: Дизайн и контракты
*Предварительные условия: research.md завершен*

1. **Извлечь сущности из спецификации функции** → `data-model.md`:
   - Имя сущности, поля, отношения
   - Правила валидации из требований
   - Переходы состояний если применимо

2. **Генерировать контракты API** из функциональных требований:
   - Для каждого пользовательского действия → эндпоинт
   - Использовать стандартные паттерны REST/GraphQL
   - Вывод схемы OpenAPI/GraphQL в `/contracts/`

3. **Генерировать тесты контрактов** из контрактов:
   - Один тестовый файл на эндпоинт
   - Проверять схемы запроса/ответа
   - Тесты должны падать (нет реализации пока)

4. **Извлечь тестовые сценарии** из пользовательских историй:
   - Каждая история → сценарий интеграционного теста
   - Быстрый старт теста = шаги валидации истории

5. **Обновить файл агента постепенно** (операция O(1)):
   - Запустить `.specify/scripts/powershell/update-agent-context.ps1 -AgentType cursor`
     **ВАЖНО**: Выполнить точно как указано выше. Не добавлять и не удалять никаких аргументов.
   - Если существует: Добавить только НОВЫЕ технологии из текущего плана
   - Сохранить ручные добавления между маркерами
   - Обновить недавние изменения (сохранить последние 3)
   - Держать под 150 строками для эффективности токенов
   - Вывод в корень репозитория

**Вывод**: data-model.md, /contracts/*, падающие тесты, quickstart.md, файл для конкретного агента

## Фаза 2: Подход к планированию задач
*Этот раздел описывает, что сделает команда /tasks - НЕ ВЫПОЛНЯТЬ во время /plan*

**Стратегия генерации задач**:
- Загрузить `.specify/templates/tasks-template.md` как основу
- Генерировать задачи из документов дизайна Фазы 1 (контракты, модель данных, быстрый старт)
- Каждый контракт → задача теста контракта [P]
- Каждая сущность → задача создания модели [P]
- Каждая пользовательская история → задача интеграционного теста
- Задачи реализации для прохождения тестов

**Стратегия упорядочивания**:
- Порядок TDD: Тесты перед реализацией
- Порядок зависимостей: Модели перед сервисами перед UI
- Пометить [P] для параллельного выполнения (независимые файлы)

**Ожидаемый вывод**: 25-30 пронумерованных, упорядоченных задач в tasks.md

**ВАЖНО**: Эта фаза выполняется командой /tasks, НЕ командой /plan

## Фазы 3+: Будущая реализация
*Эти фазы выходят за рамки команды /plan*

**Фаза 3**: Выполнение задач (команда /tasks создает tasks.md)  
**Фаза 4**: Реализация (выполнение tasks.md следуя конституционным принципам)  
**Фаза 5**: Валидация (запуск тестов, выполнение quickstart.md, валидация производительности)

## Отслеживание сложности
*Заполнять ТОЛЬКО если Проверка конституции имеет нарушения, которые должны быть обоснованы*

| Нарушение | Зачем нужно | Почему отклонена более простая альтернатива |
|-----------|------------|-------------------------------------------|
| [например, 4-й проект] | [текущая потребность] | [почему 3 проекта недостаточно] |
| [например, паттерн репозитория] | [конкретная проблема] | [почему прямой доступ к БД недостаточен] |


## Отслеживание прогресса
*Этот контрольный список обновляется во время выполнения потока*

**Статус фаз**:
- [ ] Фаза 0: Исследование завершено (команда /plan)
- [ ] Фаза 1: Дизайн завершен (команда /plan)
- [ ] Фаза 2: Планирование задач завершено (команда /plan - описать подход только)
- [ ] Фаза 3: Задачи сгенерированы (команда /tasks)
- [ ] Фаза 4: Реализация завершена
- [ ] Фаза 5: Валидация пройдена

**Статус ворот**:
- [ ] Начальная проверка конституции: ПРОЙДЕНО
- [ ] Пост-дизайн проверка конституции: ПРОЙДЕНО
- [ ] Все ТРЕБУЕТ УТОЧНЕНИЯ разрешены
- [ ] Отклонения сложности документированы

---
*На основе Конституции v2.1.1 - См. `/memory/constitution.md`*
